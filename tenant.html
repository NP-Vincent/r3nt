<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>r3nt Listings</title>

  <meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://r3nt.sqmu.net/assets/icon.png","button":{"title":"Open r3nt","action":{"type":"launch_miniapp","name":"r3nt","url":"https://r3nt.sqmu.net/index.html","splashImageUrl":"https://r3nt.sqmu.net/assets/splashscreen.png","splashBackgroundColor":"#FFFFFF"}}}' />

  <style>
    :root { --fg:#0f172a; --bg:#ffffff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; max-width: 480px; margin: 0 auto; padding: 20px; background: var(--bg); color: var(--fg); }
    button { width: 100%; padding: 12px 16px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #connect { background: #1f6feb; color: #fff; }
    .secondary { background: #0ea5e9; color: #fff; margin-top: 10px; }
    #status { margin-top: 14px; min-height: 24px; font-size: 0.95rem; color: #444; }
    #address { margin-top: 6px; font-family: ui-monospace, Menlo, monospace; color: #333; }
    #listings { margin-top: 20px; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:12px; margin-bottom:12px; background:#fff; }
    .row { display:flex; gap:8px; }
    nav { margin-bottom:16px; }
    nav a { margin-right:10px; color:#1f6feb; text-decoration:none; font-weight:600; }
    select, input[type="date"] { width:100%; padding:8px; border:1px solid #d1d5db; border-radius:8px; }
    a.listing-link { display:inline-block; margin-top:8px; color:#1f6feb; font-weight:600; text-decoration:none; }
    a.listing-link:hover { text-decoration:underline; }
    .muted { color:#666; font-size:0.9rem; }
    .badge { display:inline-block; background:#eef2ff; color:#3730a3; padding:2px 8px; border-radius:999px; font-size:0.75rem; margin-right:4px; }
  </style>
</head>
<body>
  <nav>
    <a href="./index.html">Home</a>
    <a href="./tenant.html">Tenant</a>
    <a href="./landlord.html">Landlord</a>
    <a href="./admin.html">Admin</a>
  </nav>
  <h1>r3nt Listings</h1>
  <button id="connect">Connect Wallet</button>
  <div id="address">Not connected</div>
  <div id="feeInfo" class="muted">Loading platform fees…</div>
  <div id="status">Loading listings…</div>
  <h2>Select Dates</h2>
  <div class="row">
    <label style="flex:1">Start
      <input type="date" id="startDate">
    </label>
    <label style="flex:1">End
      <input type="date" id="endDate">
    </label>
  </div>
  <p class="muted">Bookings reserve the property and escrow the deposit. Rent is paid later through the listing contract.</p>
  <div id="listings"></div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    import { encodeFunctionData, createPublicClient, http, erc20Abi } from 'https://esm.sh/viem@2.9.32';
    import { arbitrum } from 'https://esm.sh/viem/chains';
    import { bytes32ToCastHash, buildFarcasterCastUrl } from './js/tools.js';
    import {
      CHAIN_ID,
      RPC_URL,
      PLATFORM_ADDRESS,
      PLATFORM_ABI,
      LISTING_ABI,
      REGISTRY_ADDRESS,
      REGISTRY_ABI,
      USDC_ADDRESS
    } from './js/config.js';

    const CHAIN_ID_HEX = '0x' + CHAIN_ID.toString(16);
    const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
    const SECONDS_PER_DAY = 86_400n;

    const els = {
      connect: document.getElementById('connect'),
      addr: document.getElementById('address'),
      status: document.getElementById('status'),
      listings: document.getElementById('listings'),
      start: document.getElementById('startDate'),
      end: document.getElementById('endDate'),
      feeInfo: document.getElementById('feeInfo'),
    };

    const pub = createPublicClient({ chain: arbitrum, transport: http(RPC_URL || 'https://arb1.arbitrum.io/rpc') });

    let bookingRegistryAddress = REGISTRY_ADDRESS;
    let usdcAddress = USDC_ADDRESS;

    function formatUsdc(amount) {
      const n = typeof amount === 'bigint' ? amount : BigInt(amount || 0);
      const negative = n < 0n;
      const abs = negative ? -n : n;
      const units = abs / 1_000_000n;
      const fraction = abs % 1_000_000n;
      const fractionStr = fraction.toString().padStart(6, '0').replace(/0+$/, '');
      return `${negative ? '-' : ''}${units.toString()}${fractionStr ? '.' + fractionStr : ''}`;
    }

    function short(addr) {
      return addr ? `${addr.slice(0,6)}…${addr.slice(-4)}` : '';
    }

    function formatDuration(seconds) {
      const sec = Number(seconds || 0n);
      if (sec === 0) return '0d';
      if (sec < 86400) {
        const hours = Math.max(1, Math.round(sec / 3600));
        return `${hours}h`;
      }
      const days = sec / 86400;
      if (Number.isInteger(days)) {
        return `${days}d`;
      }
      return `${days.toFixed(1)}d`;
    }

    async function ensureArbitrum(p) {
      const id = await p.request({ method:'eth_chainId' });
      if (id !== CHAIN_ID_HEX) {
        try {
          await p.request({ method:'wallet_switchEthereumChain', params:[{ chainId: CHAIN_ID_HEX }] });
        } catch {
          await p.request({
            method:'wallet_addEthereumChain',
            params:[{
              chainId: CHAIN_ID_HEX,
              chainName:'Arbitrum One',
              nativeCurrency:{ name:'Ether', symbol:'ETH', decimals:18 },
              rpcUrls:[RPC_URL || 'https://arb1.arbitrum.io/rpc'],
              blockExplorerUrls:['https://arbiscan.io']
            }]
          });
        }
      }
    }

    function calculateRent(baseDailyRate, startTs, endTs) {
      let duration = endTs - startTs;
      if (duration < 0n) duration = 0n;
      let days = (duration + SECONDS_PER_DAY - 1n) / SECONDS_PER_DAY;
      if (days === 0n) days = 1n;
      return baseDailyRate * days;
    }

    async function hostSupportsWallet(){
      try {
        const caps = await sdk.getCapabilities?.();
        return !caps || caps.includes('wallet.getEthereumProvider');
      } catch {
        return true;
      }
    }

    let provider;
    function setStatus(message) {
      els.status.textContent = message;
    }

    async function loadPlatformMeta() {
      try {
        const [fees, creationFee, modules, usdcAddr] = await Promise.all([
          pub.readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName:'fees' }),
          pub.readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName:'listingCreationFee' }),
          pub.readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName:'modules' }),
          pub.readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName:'usdc' })
        ]);
        const feeTuple = Array.isArray(fees) ? fees : [0n, 0n];
        const tenantBps = feeTuple[0] ?? 0n;
        const landlordBps = feeTuple[1] ?? 0n;
        const registryAddr = Array.isArray(modules) ? modules[1] : undefined;
        if (registryAddr && registryAddr !== ZERO_ADDRESS) {
          bookingRegistryAddress = registryAddr;
        }
        if (usdcAddr && usdcAddr !== ZERO_ADDRESS) {
          usdcAddress = usdcAddr;
        }
        const tenantPct = (Number(tenantBps || 0n) / 100).toFixed(2);
        const landlordPct = (Number(landlordBps || 0n) / 100).toFixed(2);
        els.feeInfo.textContent = `Platform fees (tenant/landlord): ${tenantPct}% / ${landlordPct}% · Listing creation fee: ${formatUsdc(creationFee || 0n)} USDC`;
      } catch {
        els.feeInfo.textContent = 'Unable to load platform fee information.';
      }
    }

    async function fetchListingAddresses() {
      const count = await pub.readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName:'listingCount' });
      const total = Number(count || 0n);
      const addresses = [];
      for (let i = 1; i <= total; i++) {
        const addr = await pub.readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName:'listingById', args:[BigInt(i)] });
        if (addr && addr !== ZERO_ADDRESS) {
          addresses.push({ id: i, address: addr });
        }
      }
      return addresses;
    }

    async function loadListings() {
      try {
        setStatus('Loading listings…');
        const addresses = await fetchListingAddresses();
        els.listings.innerHTML = '';
        if (!addresses.length) {
          setStatus('No listings available.');
          return;
        }

        for (const { id, address } of addresses) {
          try {
            const [baseDailyRate, depositAmount, areaSqm, metadataURI, fid, castHash, minNotice, maxWindow] = await Promise.all([
              pub.readContract({ address, abi: LISTING_ABI, functionName:'baseDailyRate' }),
              pub.readContract({ address, abi: LISTING_ABI, functionName:'depositAmount' }),
              pub.readContract({ address, abi: LISTING_ABI, functionName:'areaSqm' }),
              pub.readContract({ address, abi: LISTING_ABI, functionName:'metadataURI' }),
              pub.readContract({ address, abi: LISTING_ABI, functionName:'fid' }),
              pub.readContract({ address, abi: LISTING_ABI, functionName:'castHash' }),
              pub.readContract({ address, abi: LISTING_ABI, functionName:'minBookingNotice' }),
              pub.readContract({ address, abi: LISTING_ABI, functionName:'maxBookingWindow' })
            ]);

            const listingData = {
              id,
              address,
              baseDailyRate,
              depositAmount,
              areaSqm,
              metadataURI,
              fid,
              castHash,
              minNotice,
              maxWindow
            };
            renderListingCard(listingData);
          } catch (err) {
            console.error('Failed to load listing', id, err);
          }
        }
        setStatus('Select a listing and submit booking.');
      } catch (err) {
        console.error(err);
        setStatus('Failed to load listings.');
      }
    }

    function renderListingCard(listing) {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.listingId = listing.id;
      card.dataset.address = listing.address;
      card.dataset.deposit = listing.depositAmount.toString();
      card.dataset.baseDailyRate = listing.baseDailyRate.toString();
      card.dataset.minNotice = listing.minNotice.toString();
      card.dataset.maxWindow = listing.maxWindow.toString();

      const title = document.createElement('strong');
      title.textContent = listing.metadataURI ? `Listing ${listing.id}` : `Listing ${listing.id}`;
      card.appendChild(title);

      if (listing.metadataURI) {
        const metaLink = document.createElement('a');
        metaLink.href = listing.metadataURI;
        metaLink.target = '_blank';
        metaLink.rel = 'noopener';
        metaLink.textContent = 'Metadata';
        metaLink.className = 'listing-link';
        card.appendChild(metaLink);
      }

      const rates = document.createElement('div');
      rates.textContent = `Base rate: ${formatUsdc(listing.baseDailyRate)} USDC / day`;
      card.appendChild(rates);

      const deposit = document.createElement('div');
      deposit.textContent = `Deposit: ${formatUsdc(listing.depositAmount)} USDC`;
      card.appendChild(deposit);

      const area = document.createElement('div');
      const areaValue = typeof listing.areaSqm === 'bigint' ? Number(listing.areaSqm) : Number(listing.areaSqm || 0);
      if (areaValue > 0) {
        area.textContent = `Area: ${areaValue} m²`;
        card.appendChild(area);
      }

      const badges = document.createElement('div');
      badges.className = 'muted';
      const badgeNotice = document.createElement('span');
      badgeNotice.className = 'badge';
      badgeNotice.textContent = `Min notice: ${formatDuration(listing.minNotice)}`;
      badges.appendChild(badgeNotice);
      const badgeWindow = document.createElement('span');
      badgeWindow.className = 'badge';
      badgeWindow.textContent = listing.maxWindow > 0n ? `Window: ${formatDuration(listing.maxWindow)}` : 'Window: unlimited';
      badges.appendChild(badgeWindow);
      card.appendChild(badges);

      const actions = document.createElement('div');
      actions.className = 'row';
      const btnBook = document.createElement('button');
      btnBook.textContent = 'Book';
      btnBook.onclick = () => bookListing(listing);
      actions.appendChild(btnBook);
      card.appendChild(actions);

      const farcasterUrl = buildFarcasterCastUrl(listing.fid, listing.castHash);
      const viewLink = document.createElement('a');
      viewLink.href = farcasterUrl;
      viewLink.target = '_blank';
      viewLink.rel = 'noopener';
      viewLink.textContent = 'View listing on Farcaster';
      viewLink.className = 'listing-link';
      viewLink.onclick = (ev) => {
        ev.preventDefault();
        openCast(listing.fid, listing.castHash, farcasterUrl);
      };
      card.appendChild(viewLink);

      els.listings.appendChild(card);
    }

    async function openCast(fid, hash32, fallbackUrl) {
      const cast20 = bytes32ToCastHash(hash32);
      try {
        await sdk.actions.viewCast({ hash: cast20 });
      } catch {
        window.open(fallbackUrl, '_blank');
      }
    }

    async function bookListing(listing) {
      try {
        const start = els.start.value;
        const end = els.end.value;
        if (!start || !end) { setStatus('Select start and end dates first.'); return; }
        const startTs = BigInt(Date.parse(start + 'T00:00:00Z') / 1000);
        const endTs = BigInt(Date.parse(end + 'T00:00:00Z') / 1000);
        if (endTs <= startTs) throw new Error('End date must be after start date.');

        const nowSec = BigInt(Math.floor(Date.now() / 1000));
        const minNotice = BigInt(listing.minNotice);
        const maxWindow = BigInt(listing.maxWindow);
        if (startTs < nowSec + minNotice) {
          throw new Error('Start date violates minimum notice.');
        }
        if (maxWindow > 0n && startTs > nowSec + maxWindow) {
          throw new Error('Start date exceeds booking window.');
        }

        if (!bookingRegistryAddress || bookingRegistryAddress === ZERO_ADDRESS) {
          throw new Error('Booking registry not configured on platform.');
        }
        const available = await pub.readContract({ address: bookingRegistryAddress, abi: REGISTRY_ABI, functionName:'isAvailable', args:[listing.address, startTs, endTs] });
        if (!available) {
          throw new Error('Selected range is not available.');
        }

        const rent = calculateRent(BigInt(listing.baseDailyRate), startTs, endTs);
        const deposit = BigInt(listing.depositAmount);
        const totalDueNow = deposit;

        const p = provider || await sdk.wallet.getEthereumProvider();
        provider = p;
        await p.request({ method:'eth_requestAccounts' });
        await ensureArbitrum(p);
        const [from] = await p.request({ method:'eth_accounts' }) || [];
        if (!from) throw new Error('No wallet account connected.');

        if (!usdcAddress || usdcAddress === ZERO_ADDRESS) {
          throw new Error('USDC address not configured on platform.');
        }
        const approveData = deposit > 0n ? encodeFunctionData({ abi: erc20Abi, functionName:'approve', args:[listing.address, deposit] }) : null;
        const bookData = encodeFunctionData({ abi: LISTING_ABI, functionName:'book', args:[startTs, endTs] });

        setStatus(`Submitting booking… Deposit ${formatUsdc(totalDueNow)} USDC. Rent due over stay: ${formatUsdc(rent)} USDC.`);

        const calls = [];
        if (approveData) {
          calls.push({ to: usdcAddress, data: approveData });
        }
        calls.push({ to: listing.address, data: bookData });

        try {
          await p.request({ method:'wallet_sendCalls', params:[{ calls }] });
        } catch {
          if (approveData) {
            await p.request({ method:'eth_sendTransaction', params:[{ from, to: usdcAddress, data: approveData }] });
          }
          await p.request({ method:'eth_sendTransaction', params:[{ from, to: listing.address, data: bookData }] });
        }

        setStatus('Booking transaction submitted. Deposit is now escrowed.');
      } catch (err) {
        console.error(err);
        setStatus(err?.message || 'Booking failed.');
      }
    }

    els.connect.onclick = async () => {
      try {
        const inHost = await sdk.isInMiniApp?.();
        if (inHost === false) {
          setStatus('Open inside a Farcaster client to connect a wallet.');
          return;
        }
        if (!(await hostSupportsWallet())) {
          setStatus('This client does not expose wallet capabilities.');
          return;
        }
        const p = await sdk.wallet.getEthereumProvider();
        provider = p;
        await p.request({ method:'eth_requestAccounts' });
        const [addr] = await p.request({ method:'eth_accounts' });
        if (!addr) throw new Error('No account available.');
        await ensureArbitrum(p);
        els.addr.textContent = `Connected: ${short(addr)}`;
        els.connect.textContent = `Connected ${short(addr)}`;
        els.connect.style.background = '#10b981';
        setStatus('Wallet connected. Choose dates and book.');
      } catch (err) {
        console.error(err);
        setStatus(err?.message || 'Wallet connection failed.');
      }
    };

    (async () => {
      try { await sdk.actions.ready(); } catch {}
      await loadPlatformMeta();
      await loadListings();
    })();
  </script>
</body>
</html>

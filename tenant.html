<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>r3nt View Pass</title>

  <meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://r3nt.sqmu.net/assets/icon.png","button":{"title":"Open r3nt","action":{"type":"launch_miniapp","name":"r3nt","url":"https://r3nt.sqmu.net/index.html","splashImageUrl":"https://r3nt.sqmu.net/assets/splashscreen.png","splashBackgroundColor":"#FFFFFF"}}}' />

  <style>
    :root { --fg:#0f172a; --bg:#ffffff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; max-width: 460px; margin: 0 auto; padding: 20px; background: var(--bg); color: var(--fg); }
    button { width: 100%; padding: 12px 16px; border: 0; border-radius: 10px; font-weight: 700; cursor: pointer; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #connect { background: #1f6feb; color: #fff; }
    #buy { background: #10b981; color: #fff; margin-top: 10px; }
    #status { margin-top: 14px; min-height: 24px; font-size: 0.95rem; color: #444; }
    #address { margin-top: 6px; font-family: ui-monospace, Menlo, monospace; color: #333; }
    #listings { margin-top: 20px; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:12px; margin-bottom:10px; }
    .row { display:flex; gap:8px; }
    nav { margin-bottom:16px; }
    nav a { margin-right:10px; color:#1f6feb; text-decoration:none; font-weight:600; }
    select { width:100%; padding:6px; margin:4px 0 8px; }
    a.listing-link { display:inline-block; margin-top:8px; color:#1f6feb; font-weight:600; text-decoration:none; }
    a.listing-link:hover { text-decoration:underline; }
  </style>
</head>
<body>
  <nav>
    <a href="./index.html">Home</a>
    <a href="./tenant.html">Tenant</a>
    <a href="./landlord.html">Landlord</a>
    <a href="./admin.html">Admin</a>
  </nav>
  <h1>r3nt View Pass</h1>
  <button id="connect">Connect Wallet</button>
  <div id="address">Not connected</div>
  <button id="buy" disabled>Buy View Pass</button>
  <div id="status">Loading…</div>
  <h2>Select Dates</h2>
  <div class="row">
    <label>Start
      <input type="date" id="startDate">
    </label>
    <label>End
      <input type="date" id="endDate">
    </label>
  </div>
  <h2>Listings</h2>
  <div id="listings"></div>

  <!-- 1) READY FIRST -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    (async () => { try { await sdk.actions.ready(); } catch {} setTimeout(()=>{ try { sdk.actions.ready(); } catch {} }, 800); })();
  </script>

  <!-- 2) APP LOGIC -->
  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    import { encodeFunctionData, erc20Abi, createPublicClient, http } from 'https://esm.sh/viem@2.9.32';
    import { arbitrum } from 'https://esm.sh/viem/chains';
    import { bytes32ToCastHash, buildFarcasterCastUrl } from './js/tools.js';
    import {
      RPC_URL,
      R3NT_ADDRESS,
      REGISTRY_ADDRESS,
      REGISTRY_ABI,
      PLATFORM_ADDRESS,
      PLATFORM_ABI,
      USDC_ADDRESS,
    } from './js/config.js';

    const els = {
      connect: document.getElementById('connect'),
      buy: document.getElementById('buy'),
      addr: document.getElementById('address'),
      status: document.getElementById('status'),
      listings: document.getElementById('listings'),
      start: document.getElementById('startDate'),
      end: document.getElementById('endDate'),
    };

    const ARBITRUM_HEX = '0xa4b1';           // 42161
    const USDC_SCALAR = 1_000_000n;

    function formatUsdc(amount) {
      const value = typeof amount === 'bigint' ? amount : BigInt(amount || 0);
      const negative = value < 0n;
      const abs = negative ? -value : value;
      const units = abs / USDC_SCALAR;
      const fraction = (abs % USDC_SCALAR).toString().padStart(6, '0').replace(/0+$/, '');
      return `${negative ? '-' : ''}${units.toString()}${fraction ? '.' + fraction : ''}`;
    }

    let inHost = false; try { inHost = await sdk.isInMiniApp(); } catch {}
    els.status.textContent = inHost ? 'Tap Connect to continue.' : 'Viewing only. Open from a Farcaster Mini App embed.';

    async function hostSupportsWallet(){ try { const caps = await sdk.getCapabilities?.(); return !caps || caps.includes('wallet.getEthereumProvider'); } catch { return true; } }

    let provider; async function getProvider(){ if (!provider) provider = await sdk.wallet.getEthereumProvider(); return provider; }

    async function ensureArbitrum(p){ const id = await p.request({ method:'eth_chainId' }); if (id !== ARBITRUM_HEX) { try { await p.request({ method:'wallet_switchEthereumChain', params:[{ chainId: ARBITRUM_HEX }] }); } catch { try { await p.request({ method:'wallet_addEthereumChain', params:[{ chainId: ARBITRUM_HEX, chainName:'Arbitrum One', nativeCurrency:{ name:'Ether', symbol:'ETH', decimals:18 }, rpcUrls:['https://arb1.arbitrum.io/rpc'], blockExplorerUrls:['https://arbiscan.io'] }] }); } catch {} } } }

    function short(a){ return a ? `${a.slice(0,6)}…${a.slice(-4)}` : ''; }

    let r3ntAbi, pub, feeBps, bookingAbi, bookingAddr;
    let viewPassPrice;
    let configLoading;

    function updateBuyLabel() {
      if (typeof viewPassPrice === 'bigint') {
        els.buy.textContent = `Buy View Pass (${formatUsdc(viewPassPrice)} USDC)`;
      } else {
        els.buy.textContent = 'Buy View Pass';
      }
    }

    async function loadConfig(){
      if (configLoading) {
        await configLoading;
        return;
      }
      if (pub && r3ntAbi && bookingAbi) {
        if (typeof viewPassPrice !== 'bigint') {
          try {
            const price = await pub.readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName: 'viewPassPrice' });
            if (typeof price === 'bigint') {
              viewPassPrice = price;
            }
            updateBuyLabel();
          } catch (err) {
            console.error('Failed to load view pass price', err);
          }
        }
        return;
      }
      configLoading = (async () => {
        if (!r3ntAbi) {
          r3ntAbi = await fetch('./js/abi/r3nt.json').then(r => r.json()).then(j => j.abi);
        }
        bookingAbi = REGISTRY_ABI;
        bookingAddr = REGISTRY_ADDRESS;
        pub = createPublicClient({ chain: arbitrum, transport: http(RPC_URL || 'https://arb1.arbitrum.io/rpc') });
        const [fee, price] = await Promise.all([
          pub.readContract({ address: R3NT_ADDRESS, abi: r3ntAbi, functionName: 'feeBps' }),
          pub
            .readContract({ address: PLATFORM_ADDRESS, abi: PLATFORM_ABI, functionName: 'viewPassPrice' })
            .catch((err) => {
              console.error('Failed to load view pass price', err);
              return undefined;
            }),
        ]);
        feeBps = fee;
        if (typeof price === 'bigint') {
          viewPassPrice = price;
        }
        updateBuyLabel();
      })();
      try {
        await configLoading;
      } finally {
        configLoading = null;
      }
    }

    async function openCast(fid, hash32, fallbackUrl){
      const cast20 = bytes32ToCastHash(hash32);
      try {
        await sdk.actions.viewCast({ hash: cast20 });
      } catch {
        // fallback: open in Warpcast via the generated profile-aware URL
        window.open(fallbackUrl, '_blank');
      }
    }

    async function loadListings(){
      await loadConfig();
      els.listings.textContent = 'Loading listings…';
      const count = Number(await pub.readContract({ address: R3NT_ADDRESS, abi: r3ntAbi, functionName: 'listingsCount' }));
      const items = await Promise.all(
        Array.from({length: count}, (_,i)=> pub.readContract({ address: R3NT_ADDRESS, abi: r3ntAbi, functionName: 'getListing', args:[ BigInt(i) ] }).then(L=>({i, L})))
      );
      els.listings.innerHTML = '';
      let shown = 0;
      for (const {i, L} of items) {
        if (!L.active) continue;
        shown++;
        const card = document.createElement('div');
        card.className = 'card';
        const title = document.createElement('div');
        title.textContent = L.title || `Listing ${i}`;
        const rateLabel = document.createElement('label');
        rateLabel.textContent = 'Rent: ';
        const sel = document.createElement('select');
        if (Number(L.rateDaily) > 0) {
          const o = document.createElement('option');
          o.value = L.rateDaily;
          o.dataset.rtype = '0';
          o.textContent = `Daily - ${Number(L.rateDaily)/1e6} USDC`;
          sel.appendChild(o);
        }
        if (Number(L.rateWeekly) > 0) {
          const o = document.createElement('option');
          o.value = L.rateWeekly;
          o.dataset.rtype = '1';
          o.textContent = `Weekly - ${Number(L.rateWeekly)/1e6} USDC`;
          sel.appendChild(o);
        }
        if (Number(L.rateMonthly) > 0) {
          const o = document.createElement('option');
          o.value = L.rateMonthly;
          o.dataset.rtype = '2';
          o.textContent = `Monthly - ${Number(L.rateMonthly)/1e6} USDC`;
          sel.appendChild(o);
        }
        rateLabel.appendChild(sel);
        const dep = document.createElement('div');
        dep.textContent = `Deposit: ${Number(L.deposit)/1e6} USDC`;
        const areaVal = typeof L.areaSqm === 'bigint' ? Number(L.areaSqm) : Number(L.areaSqm || 0);
        const area = areaVal > 0 ? document.createElement('div') : null;
        if (area) {
          area.textContent = `Area: ${areaVal} m²`;
        }

        const row = document.createElement('div');
        row.className = 'row';
        const btnBook = document.createElement('button');
        btnBook.textContent = 'Book';
        btnBook.onclick = () => {
          const opt = sel.options[sel.selectedIndex];
          bookListing(i, BigInt(opt.dataset.rtype), opt.value, L.deposit);
        };
        row.appendChild(btnBook);

        const farcasterUrl = buildFarcasterCastUrl(L.fid, L.castHash);
        const viewLink = document.createElement('a');
        viewLink.href = farcasterUrl;
        viewLink.target = '_blank';
        viewLink.rel = 'noopener';
        viewLink.textContent = 'View full details on Farcaster';
        viewLink.className = 'listing-link';
        viewLink.onclick = (ev) => {
          ev.preventDefault();
          openCast(L.fid, L.castHash, farcasterUrl);
        };

        card.appendChild(title);
        card.appendChild(rateLabel);
        card.appendChild(dep);
        if (area) card.appendChild(area);
        card.appendChild(row);
        card.appendChild(viewLink);
        els.listings.appendChild(card);
      }
      if (!shown) els.listings.textContent = 'No active listings.';
    }

    async function bookListing(listingId, rtype, rate, deposit){
      try {
        const p = await getProvider();
        const [from] = await p.request({ method: 'eth_accounts' }) || [];
        if (!from) throw new Error('No wallet account connected.');
        await ensureArbitrum(p);
        await loadConfig();

        const start = els.start.value;
        const end = els.end.value;
        if (!start || !end) throw new Error('Select start and end dates.');
        const startTs = BigInt(Date.parse(start + 'T00:00:00Z') / 1000);
        const endTs = BigInt(Date.parse(end + 'T00:00:00Z') / 1000);
        if (endTs <= startTs) throw new Error('End date must be after start.');
        const dur = rtype === 1n ? 7n * 86400n : rtype === 2n ? 30n * 86400n : 86400n;
        const diff = endTs - startTs;
        if (diff % dur !== 0n) throw new Error('Date range misaligned with rate type.');
        const units = diff / dur;

        const listing = await pub.readContract({ address: R3NT_ADDRESS, abi: r3ntAbi, functionName:'getListing', args:[BigInt(listingId)] });
        const free = await pub.readContract({ address: bookingAddr, abi: bookingAbi, functionName:'isFree', args:[listing.vault, startTs, endTs] });
        if (!free) { els.status.textContent = 'Selected dates not available.'; return; }

        const rent = BigInt(rate) * units;
        const dep = BigInt(deposit);
        const fee = rent * BigInt(feeBps) / 10000n;
        const total = rent + fee + dep;

        const approveData = encodeFunctionData({ abi: erc20Abi, functionName: 'approve', args: [R3NT_ADDRESS, total] });
        const bookData = encodeFunctionData({ abi: r3ntAbi, functionName: 'book', args: [BigInt(listingId), rtype, units, startTs, endTs] });

        els.status.textContent = 'Submitting booking…';

        try {
          await p.request({ method:'wallet_sendCalls', params:[{ calls: [ { to: USDC_ADDRESS, data: approveData }, { to: R3NT_ADDRESS, data: bookData } ] }] });
        } catch {
          try {
            await p.request({ method:'wallet_sendCalls', params:[ { to: USDC_ADDRESS, data: approveData }, { to: R3NT_ADDRESS, data: bookData } ] });
          } catch {
            await p.request({ method:'eth_sendTransaction', params:[{ from, to: USDC_ADDRESS, data: approveData }] });
            await p.request({ method:'eth_sendTransaction', params:[{ from, to: R3NT_ADDRESS, data: bookData }] });
          }
        }

        els.status.textContent = 'Booking submitted.';
        alert('Booking transaction sent!');
      } catch (e) {
        console.error(e);
        els.status.textContent = `Error: ${e?.message || e}`;
      }
    }

    async function checkViewPass(addr){
      try {
        await loadConfig();
        const expiry = await pub.readContract({ address: R3NT_ADDRESS, abi: r3ntAbi, functionName: 'viewPassExpiry', args: [addr] });
        const active = expiry > BigInt(Math.floor(Date.now()/1000));
        if (active) {
          const ts = Number(expiry) * 1000; const d = new Date(ts).toISOString().replace('T',' ').slice(0,16);
          els.status.textContent = `View pass active. Expires: ${d} UTC.`;
          await loadListings();
        } else {
          els.status.textContent = 'No active view pass. Buy to see listings.';
        }
      } catch (e) { console.error(e); els.status.textContent = 'Unable to verify view pass.'; }
    }

    // ——— Connect ———
    els.connect.onclick = async () => {
      try {
        if (!inHost) { els.status.textContent = 'Open in Farcaster app to connect wallet.'; return; }
        if (!(await hostSupportsWallet())) { els.status.textContent = 'This client does not support wallets for Mini Apps.'; return; }
        const p = await getProvider();
        await p.request({ method: 'eth_requestAccounts' });
        const [addr] = await p.request({ method: 'eth_accounts' });
        if (!addr) throw new Error('No account found.');
        await ensureArbitrum(p);
        els.addr.textContent = `Connected: ${short(addr)}`;
        els.connect.textContent = `Connected ${short(addr)}`;
        els.connect.style.background = '#10b981';
        els.buy.disabled = false;
        els.status.textContent = 'Ready.';
        await checkViewPass(addr);
      } catch (e) { console.error(e); els.status.textContent = e?.message || 'Wallet connection failed.'; }
    };

    // ——— Buy pass ———
    els.buy.onclick = async () => {
      try {
        const p = await getProvider();
        const [from] = await p.request({ method: 'eth_accounts' }) || [];
        if (!from) throw new Error('No wallet account connected.');
        await ensureArbitrum(p);
        await loadConfig();
        const price = typeof viewPassPrice === 'bigint' ? viewPassPrice : 0n;
        if (typeof viewPassPrice !== 'bigint') {
          console.warn('View pass price unavailable, defaulting to 0.');
        }
        let approveData;
        const calls = [];
        if (price > 0n) {
          approveData = encodeFunctionData({ abi: erc20Abi, functionName: 'approve', args: [PLATFORM_ADDRESS, price] });
          calls.push({ to: USDC_ADDRESS, data: approveData });
        }
        const buyData = encodeFunctionData({ abi: PLATFORM_ABI, functionName: 'buyViewPass', args: [] });
        calls.push({ to: PLATFORM_ADDRESS, data: buyData });
        els.status.textContent = price > 0n ? 'Approving & purchasing…' : 'Purchasing view pass…';
        try {
          await p.request({ method:'wallet_sendCalls', params:[{ calls }] });
        } catch {
          try {
            await p.request({ method:'wallet_sendCalls', params: calls });
          } catch {
            if (price > 0n && approveData) {
              await p.request({ method: 'eth_sendTransaction', params: [{ from, to: USDC_ADDRESS, data: approveData }] });
            }
            await p.request({ method: 'eth_sendTransaction', params: [{ from, to: PLATFORM_ADDRESS, data: buyData }] });
          }
        }
        els.status.textContent = 'Success. View pass purchased.';
        alert('View pass purchased!');
        await checkViewPass(from);
      } catch (err) { console.error(err); els.status.textContent = `Error: ${err?.message || err}`; }
    };

    loadConfig().catch((err) => console.error('Initial config load failed', err));
  </script>
</body>
</html>
